# 11.17 JAVA
## 이름 변경하는 방법
- class 이름 오른쪽 클릭 - Refactor - rename

## ♠ 클래스 객체(인스턴스 생성 방법)
- 클래스명 참조변수명 - new 클래스명(); -> 클래스명() 은 클래스 생성자 메소드 호출이다.

## ♠ 클래스 관계 - 상속, 포함.
1.  상속
- 부모자식 관계
- 부모클래스
  - 자식 1 클래스.
  - 자식 2 클래스.
  - 자식 3 클래스.
```html
<div class="width">
  <div class="font">
    <img>
    <input>
  </div>
</div>
```
- . width에 width = 300px;을 주면 그의 자식들에게도 똑같이 300px 이 됨.
- .font 에 font-size = 15px 을 주면 그의 자식들에게 똑같이 폰트가 15px 이 되지만, 그의 부모인 .width 에는 적용이 되지 않는다.
- 상속관계
  - 상속관계를 하는 이유는?
    - 편하게 관리하기 위해서...
    - 재활용성(자바의 상속이란 기존 클래스를 재사용하여 새로운 클래스를 작성하는 것.)
    - 코드의 중복성 제거.
    - 프로그램 생산성과 유지보수 UP!
  - 다형성 (class의 꽃 💐)
    - 다양한 여러가지 형태의 성질을 가지는 것.
    - 자바 다형성 
      - 하나의 클래스로 여러 클래스를 표현 할 수 있는 방식.
    - 다형성 구형할 수 있는 방법.
      - class 간의 상속관계가 있어야함.
      - interface 를 이용.
    - 다형성을 사용하는 이유?
      * 변수 대신 배열을 사용하는 이유? 여러가지 데이터를 하나로 묶기 위해
      * 서로 다른 타입의 class 를 하나의 class로 묶어서 사용하기 위해 사용.
    - 다형성의 장점 
      - 어떤 class를 사용하던 간에 동일한 메소드를 사용가능.
      - 
    - 다형성의 단점
      ```java
      house_item[] t = new tv[] {
				new tv("삼성",1230000,65),
				new tv("LG",1505000,65),
				new tv("삼성",890000,55),
				new tv("LG",224000,75),
				new tv("삼성",73000,50),
				};
		
		house_item[] air = new aircon[] {
					new aircon("휘센",1510510,17),
					new aircon("캐리어",1619800,25),
					new aircon("휘센",1587110,30),
					new aircon("위니아",189000,17),
					new aircon("비스포크",1878590,19),
					};
      ```
  - 단일상속 
    - 자식들은 한명의 부모밖에 가질 수 없음.
  - 상속관계 : ~은 ~이다.(is ~a) 
    - 에어컨은 가전제품이다. 
    - TV는 가전제품이다.

```java
class 이름 extends 부모class이름
// 자식 클래스에서 부모클래스를 정의하는 방법.
```
2. 포함관계
- 코드를 재사용할 수 있는 방법.
- 상속과는 다른 관계.
- 포함은 다른 클래스를 자신의 변수로 만들어 사용하는 방법.
```java
class a {
  int a;
}
class b{
  a temp = new a(); 
}
```
- 포함관계 : ~은 ~를 가지고 있다.(has~ a) 
  - 에어컨은 가전제품을 가지고 있다. (x)
  - 자동차는 타이어를 가지고 있다. (포함관계)
  - 가전제품은 에어컨을 가지고 있다. (x)

## ♠ 생성자 메소드
- 메소드의 실행은 반드시 메소드 명으로 실행이 되어야한다.
- 아무리 상속관계여도 자식 클래스로 생성하려고 하면 생성자 메소드가 없다면 실행이 안됨.
- 그래서 자식에게 생성자 메소드를 호출 해야함.
```java
  // 부모의 객체
public house_item(String brand, int price) {
		this.brand = brand;
		this.price = price;
		// this는 현재 생성되는 객체를 의미.
	}

  // 자식의 객체
    tv t1 = new tv("삼성",1230000);
		tv t2 = new tv("LG",985000);
		
		aircon air1 = new aircon("휘센",940000);
		aircon air2 = new aircon("위니아",560000);
		
		computer com1 = new computer("정수PC",780000);
    // new 뒤에 자식의 객체가 나왔으니 자식의 객체에 부모 생성자 메소드 호출해야 에러가 안나온다.(빨간줄이 안나옴.)

    // super 처럼 사용해야 함
```

## ♠ super()
- super는 부모다.
```java
public tv(String brand, int price) {
		super(brand,price); // 부모의 생성자 호출
	}
```
- super 는 무조건 맨 위쪽에 있어야 한다.
  -  why?  super 는 자식 클래스 생성자에서 가장 먼저 실행 될 수 있게 해야한다.
  - 객체 생성시 객체의 초기화 순서는 부모 -> 자식 순이기 때문에...!
```java
public tv(String brand, int price,int inch) {
		super(brand,price);
		this.inch = inch;
	}
```
- extends : 확장
   - 자기의 객체 + 부모의 객체(super) 
   - 자기의 객체 + 부모의 객체(extends 가 되어있는 상태라면) + 조부모의 객체

## ♠ 변수의 초기화
- 변수초기화 방법
  1. 생성자 메소드를 통해 초기화.
    - 생성자 메소드 객체 생성시 실행
  2. 초기화 블럭을 통한 초기화.
    - 초기화 블럭은 프로그램이 로드된 뒤에 딱 한번 실행
    - 초기화 블럭
      1. 인스턴스 초기화블럭 ex) { ___ }
        - 인스턴스 변수와 클래스 변수를 초기화 시킬 수 있음.
        ```java
        {
          int ch = 10;
          int sound = 8;
        }
        ```
      2.  클래스 초기화 블럭 
       - 클래스 변수만 초기화.
       ```java
       static {

       }
       ```
  3. 명시적 초기화.
    - 데이터에 직접 데이터를 넣어줌.
    ```java
    public int ch = 2;
    ```
- 변수 초기화 순서
  - 인스턴스 변수 초기화 순서 : 명시적 초기화 -> 초기화 블럭 -> 생성자 메소드
  - 클래스 변수 초기화 순서 : 명시적 초기화 -> 초기화 블럭
  
## ♠ 추상메소드
- 사용되는 클래스에 의해 다른 내용이 되는 메소드
- 세부적인 내용은 자식클래스에서 구현.
- 자식클래스에서 구현을 하기 위해 사용
- 추상메소드가 하나라도 있다면 하나의 메소드는 반드시 추상메소드가 되어야 함.

- 추상클래스
  - 추상클래스는 추상메소드를 가질 수 있다.
  - 추상클래스는 객체 생성이 불가능하다.
  - 추상화를 하는 이유?
    1. 클래스의 중복성을 제거
    2. 가독성 증가
    3. 에러율 감소
    4. 유지보수 시간 단축

  - 클래스에 객체를 만들려면 인스턴스 변수, 인스턴스메소드가 할당이 됨.
  - 변수와 메소드는 각각 공간이 할당이 됨.
  - 하지만 추상 클래스는 공간이 얼만큼 할당을 할 수가 없어서 (예측을 할 수 없음) 공간을 할당 할 수가 없다.
   - 자식쪽에 있음에도 불구하고 추상메소드를 남겨둬야 함. 자식 클래스에 가지고 있는 것은 부모도 가지고 있어야한다. 일반적인 메소드가 아니기 때문에 빨간줄이 뜸!
  ```java
    public void buy(); // 에러

    public abstract void buy(); // 변경
    public abstract class house_item {} // 변경

  ```
  - 자식클래스의 메소드에 주석걸면 오류나는 이유는 추상메소드도 물려받기 때문에, 자식도 추상메소드를 가지고 있다. 추상메소드는 객체 생성이 불가능하니, 자식클래스 메소드에 무조건 값을 입력해야한다.
  ```java
  public abstract void buy(); // 부모쪽 추상클래스.

  public void buy() { // 자식쪽 메소드
		System.out.println("TV 구매하였습니다."); // 값 필요
	}
  ```
